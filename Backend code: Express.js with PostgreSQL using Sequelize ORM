

const express = require('express');
const bodyParser = require('body-parser');
const { Sequelize, DataTypes, Op } = require('sequelize');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const cors = require('cors');

const app = express();
app.use(bodyParser.json());
app.use(cors());

// Replace connection details with your PostgreSQL settings
const sequelize = new Sequelize('dbname', 'dbuser', 'dbpass', {
  host: 'localhost',
  dialect: 'postgres',
  logging: false,
});

// Models

const User = sequelize.define('User', {
  id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
  name: { type: DataTypes.STRING(60), allowNull: false, validate: { len: [20, 60] } },
  email: { type: DataTypes.STRING, allowNull: false, unique: true, validate: { isEmail: true } },
  address: { type: DataTypes.STRING(400), allowNull: false },
  passwordHash: { type: DataTypes.STRING, allowNull: false },
  role: { type: DataTypes.ENUM('admin', 'normal', 'storeowner'), allowNull: false },
});

const Store = sequelize.define('Store', {
  id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
  name: { type: DataTypes.STRING(60), allowNull: false, validate: { len: [20, 60] } },
  email: { type: DataTypes.STRING, allowNull: true, validate: { isEmail: true } },
  address: { type: DataTypes.STRING(400), allowNull: false },
});

const Rating = sequelize.define('Rating', {
  id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
  rating: { type: DataTypes.INTEGER, allowNull: false, validate: { min: 1, max: 5 } },
});

// Relations

User.hasMany(Rating, { foreignKey: 'userId', onDelete: 'CASCADE' });
Rating.belongsTo(User, { foreignKey: 'userId' });

Store.hasMany(Rating, { foreignKey: 'storeId', onDelete: 'CASCADE' });
Rating.belongsTo(Store, { foreignKey: 'storeId' });

// Middleware: Auth & Role Check

const SECRET_KEY = 'your_jwt_secret_key';

function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) return res.sendStatus(401);
  jwt.verify(token, SECRET_KEY, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
}

function authorizeRoles(...roles) {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) return res.sendStatus(403);
    next();
  };
}

// Helpers

async function hashPassword(password) {
  return await bcrypt.hash(password, 10);
}

async function validatePassword(password) {
  const lengthValid = password.length >= 8 && password.length <= 16;
  const uppercaseValid = /[A-Z]/.test(password);
  const specialCharValid = /[^a-zA-Z0-9]/.test(password);
  return lengthValid && uppercaseValid && specialCharValid;
}

// Routes

// Register: Normal user signup
app.post('/api/auth/register', async (req, res) => {
  const { name, email, address, password } = req.body;
  if (!name || name.length < 20 || name.length > 60) return res.status(400).json({ error: 'Name must be 20-60 chars.' });
  if (!email || !/\S+@\S+\.\S+/.test(email)) return res.status(400).json({ error: 'Invalid Email' });
  if (!address || address.length > 400) return res.status(400).json({ error: 'Address max 400 chars' });
  if (!password || !(await validatePassword(password))) return res.status(400).json({ error: 'Password 8-16 chars, one uppercase and special char required' });

  try {
    const existing = await User.findOne({ where: { email } });
    if (existing) return res.status(400).json({ error: 'Email already exists' });
    const passwordHash = await hashPassword(password);
    const user = await User.create({ name, email, address, passwordHash, role: 'normal' });
    res.status(201).json({ message: 'User registered' });
  } catch (err) {
    res.status(500).json({ error: 'Registration failed', details: err.message });
  }
});

// Login
app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;
  if (!email || !password) return res.status(400).json({ error: 'Email and password required' });

  const user = await User.findOne({ where: { email } });
  if (!user) return res.status(401).json({ error: 'Invalid credentials' });
  const validPass = await bcrypt.compare(password, user.passwordHash);
  if (!validPass) return res.status(401).json({ error: 'Invalid credentials' });

  const token = jwt.sign({ id: user.id, role: user.role }, SECRET_KEY, { expiresIn: '8h' });
  res.json({ token, role: user.role, name: user.name });
});

// Update password
app.put('/api/users/password', authenticateToken, async (req, res) => {
  const { oldPassword, newPassword } = req.body;
  if (!oldPassword || !newPassword) return res.status(400).json({ error: 'Old and new passwords required' });
  if (!(await validatePassword(newPassword))) return res.status(400).json({ error: 'New password validation failed' });

  const user = await User.findByPk(req.user.id);
  if (!user) return res.sendStatus(404);
  const validOld = await bcrypt.compare(oldPassword, user.passwordHash);
  if (!validOld) return res.status(400).json({ error: 'Old password incorrect' });

  user.passwordHash = await hashPassword(newPassword);
  await user.save();
  res.json({ message: 'Password updated' });
});

// Admin: Add user or store
app.post('/api/admin/users', authenticateToken, authorizeRoles('admin'), async (req, res) => {
  const { name, email, address, password, role } = req.body;
  if (!name || name.length < 20 || name.length > 60) return res.status(400).json({ error: 'Name invalid' });
  if (!email || !/\S+@\S+\.\S+/.test(email)) return res.status(400).json({ error: 'Email invalid' });
  if (!address || address.length > 400) return res.status(400).json({ error: 'Address invalid' });
  if (!password || !(await validatePassword(password))) return res.status(400).json({ error: 'Password invalid' });
  if (!['admin', 'normal', 'storeowner'].includes(role)) return res.status(400).json({ error: 'Role invalid' });

  try {
    const existing = await User.findOne({ where: { email } });
    if (existing) return res.status(400).json({ error: 'Email exists' });
    const passwordHash = await hashPassword(password);
    const user = await User.create({ name, email, address, passwordHash, role });
    res.status(201).json({ message: 'User created' });
  } catch (err) {
    res.status(500).json({ error: 'Create user failed', details: err.message });
  }
});

app.post('/api/admin/stores', authenticateToken, authorizeRoles('admin'), async (req, res) => {
  const { name, email, address } = req.body;
  if (!name || name.length < 20 || name.length > 60) return res.status(400).json({ error: 'Store name invalid' });
  if (email && !/\S+@\S+\.\S+/.test(email)) return res.status(400).json({ error: 'Store email invalid' });
  if (!address || address.length > 400) return res.status(400).json({ error: 'Store address invalid' });

  try {
    const store = await Store.create({ name, email, address });
    res.status(201).json({ message: 'Store created' });
  } catch (err) {
    res.status(500).json({ error: 'Create store failed', details: err.message });
  }
});

// Admin Dashboard summary
app.get('/api/admin/dashboard', authenticateToken, authorizeRoles('admin'), async (req, res) => {
  const totalUsers = await User.count();
  const totalStores = await Store.count();
  const totalRatings = await Rating.count();
  res.json({ totalUsers, totalStores, totalRatings });
});

// Admin: List users with filtering and sorting
app.get('/api/admin/users', authenticateToken, authorizeRoles('admin'), async (req, res) => {
  const { name, email, address, role, sortBy = 'name', order = 'ASC' } = req.query;
  const filters = {};
  if (name) filters.name = { [Op.iLike]: %${name}% };
  if (email) filters.email = { [Op.iLike]: %${email}% };
  if (address) filters.address = { [Op.iLike]: %${address}% };
  if (role) filters.role = role;

  const users = await User.findAll({
    where: filters,
    order: [[sortBy, order.toUpperCase()]],
    attributes: ['id', 'name', 'email', 'address', 'role'],
  });

  // For store owners, include average rating of their stores
  const result = await Promise.all(users.map(async (u) => {
    if (u.role === 'storeowner') {
      const store = await Store.findOne({ where: { email: u.email } });
      if (store) {
        const avgRating = await Rating.findOne({
          where: { storeId: store.id },
          attributes: [[sequelize.fn('AVG', sequelize.col('rating')), 'avgRating']],
          raw: true,
        });
        return { ...u.toJSON(), avgRating: parseFloat(avgRating.avgRating || 0).toFixed(2) };
      }
    }
    return u;
  }));

  res.json(result);
});

// Admin: List stores with sorting
app.get('/api/admin/stores', authenticateToken, authorizeRoles('admin'), async (req, res) => {
  const { name, email, address, sortBy = 'name', order = 'ASC' } = req.query;
  const filters = {};
  if (name) filters.name = { [Op.iLike]: %${name}% };
  if (email) filters.email = { [Op.iLike]: %${email}% };
  if (address) filters.address = { [Op.iLike]: %${address}% };

  const stores = await Store.findAll({
    where: filters,
    order: [[sortBy, order.toUpperCase()]],
  });

  const result = await Promise.all(stores.map(async (s) => {
    const avgRating = await Rating.findOne({
      where: { storeId: s.id },
      attributes: [[sequelize.fn('AVG', sequelize.col('rating')), 'avgRating']],
      raw: true,
    });
    return { ...s.toJSON(), rating: parseFloat(avgRating.avgRating || 0).toFixed(2) };
  }));

  res.json(result);
});

// Normal user: List stores with user rating info and search
app.get('/api/stores', authenticateToken, authorizeRoles('normal', 'admin', 'storeowner'), async (req, res) => {
  const { name, address } = req.query;
  const filters = {};
  if (name) filters.name = { [Op.iLike]: %${name}% };
  if (address) filters.address = { [Op.iLike]: %${address}% };

  const stores = await Store.findAll({ where: filters, order: [['name', 'ASC']] });

  const result = await Promise.all(stores.map(async (store) => {
    const avgRating = await Rating.findOne({
      where: { storeId: store.id },
      attributes: [[sequelize.fn('AVG', sequelize.col('rating')), 'avgRating']],
      raw: true,
    });
    const userRating = await Rating.findOne({
      where: { storeId: store.id, userId: req.user.id },
    });
    return {
      id: store.id,
      name: store.name,
      address: store.address,
      overallRating: parseFloat(avgRating.avgRating || 0).toFixed(2),
      userSubmittedRating: userRating ? userRating.rating : null,
    };
  }));

  res.json(result);
});

// Normal user: Submit or update rating
app.post('/api/stores/:storeId/rate', authenticateToken, authorizeRoles('normal'), async (req, res) => {
  const { rating } = req.body;
  const storeId = parseInt(req.params.storeId);
  if (!rating || rating < 1 || rating > 5) return res.status(400).json({ error: 'Rating must be 1-5' });

  const store = await Store.findByPk(storeId);
  if (!store) return res.status(404).json({ error: 'Store not found' });

  let userRating = await Rating.findOne({ where: { userId: req.user.id, storeId } });
  if (userRating) {
    userRating.rating = rating;
    await userRating.save();
    return res.json({ message: 'Rating updated' });
  } else {
    await Rating.create({ userId: req.user.id, storeId, rating });
    return res.json({ message: 'Rating submitted' });
  }
});

// Store owner: Dashboard - list users who rated their store and average store rating

app.get('/api/storeowner/dashboard', authenticateToken, authorizeRoles('storeowner'), async (req, res) => {
  // Find store associated with this owner by matching email (assuming store owner email matches store email)
  const user = await User.findByPk(req.user.id);
  const store = await Store.findOne({ where: { email: user.email } });
  if (!store) return res.status(404).json({ error: 'Store not found' });

  const ratings = await Rating.findAll({
    where: { storeId: store.id },
    include: [{ model: User, attributes: ['id', 'name', 'email', 'address'] }],
  });

  const avgRating = await Rating.findOne({
    where: { storeId: store.id },
    attributes: [[sequelize.fn('AVG', sequelize.col('rating')), 'avgRating']],
    raw: true,
  });

  res.json({
    store: { id: store.id, name: store.name, address: store.address },
    averageRating: parseFloat(avgRating.avgRating || 0).toFixed(2),
    usersWhoRated: ratings.map(r => ({
      userId: r.User.id,
      name: r.User.name,
      email: r.User.email,
      address: r.User.address,
      rating: r.rating,
    })),
  });
});

// Logout is handled on frontend by discarding JWT token

// Initialize DB and start server

sequelize.sync({ alter: true }).then(() => {
  app.listen(3000, () => console.log('Server running on port 3000'));
});
